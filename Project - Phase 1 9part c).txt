******Client - Side Validation (Form) ******

                                 Form Validations
                                            ||
        =================================
      ||                                                                          ||
      \/                                                                          \/
    client (frontend => backend)                 server=>db(Schema)/ error handling

When we enter data in the form , the browser and / or the web server will check to see that the data is in the "correct format" and "within the constraints" set by the application.





*****Success & Failure Text*****
              ||                   ||
              \/                   \/
            okay            validation fail





*****Custom Error Handlng*****
to handle the error in a custom way we can write it like 
app.use((err , req , res , next) => {
res.send("Something Wnet Wrong");
 };
to show the error that we want to show to the user or if we don't do taht then we will get default error generated by the browser which is not very easy to comprehend.





*****Add Wrap Async*****

The wrapAsync function is a higher-order function designed to wrap asynchronous route handlers in Express.js. This function ensures that any errors thrown in the asynchronous functions are properly caught and passed to the next middleware (usually an error handler).

Here's a breakdown of how wrapAsync is being used and executed:

Definition of wrapAsync:

javascript
Copy code
module.exports = (fn) => {
    return (req, res, next) => {
        fn(req, res, next).catch(next);
    }
}
wrapAsync takes a function fn as an argument.
It returns a new function that takes req, res, and next as arguments.
The new function calls fn(req, res, next) and attaches a .catch(next) to handle any errors that occur in the promise returned by fn.
Usage of wrapAsync:

In your code, wrapAsync is used to wrap asynchronous route handlers to ensure errors are caught and passed to the next middleware.
Example Usage:

javascript
Copy code
app.post("/listings", wrapAsync(async (req, res, next) => {
    const newListing = new Listing(req.body.listing);
    await newListing.save();
    res.redirect("/listings");
}));
The asynchronous route handler for the POST request to /listings is wrapped in wrapAsync.
The inner function is an async function that creates a new listing and saves it to the database.
How wrapAsync Executes:
Request Handling:

When a POST request is made to /listings, the Express.js router calls the wrapped route handler.
Function Execution:

The wrapped function (req, res, next) => { fn(req, res, next).catch(next); } is called with req, res, and next.
Inside this function, fn(req, res, next) is executed, which is the async function (req, res, next) => { const newListing = new Listing(req.body.listing); await newListing.save(); res.redirect("/listings"); }.
Async/Await and Error Handling:

The async function starts executing: const newListing = new Listing(req.body.listing); await newListing.save(); res.redirect("/listings");.
If any error occurs during the execution of this async function, the promise returned by fn will be rejected.
.catch(next) catches this rejection and calls next with the error, passing the error to the next middleware in the Express.js stack, which is typically an error handler.
Custom Error Handling Middleware:
In your setup, the error is caught by the custom error handling middleware defined at the end:

javascript
Copy code
app.use((err, req, res, next) => {
    res.send("Something Went Wrong!");
});
This middleware sends a generic error message when an error is passed to next.

Summary:
wrapAsync wraps async route handlers to catch errors and pass them to the next middleware.
When the wrapped route handler is called, it executes the async function.
If an error occurs, .catch(next) catches it and forwards it to the next middleware.
Your custom error handling middleware sends a generic error message in response to any errors.
By using wrapAsync, you can ensure that errors in your async route handlers are handled consistently and avoid the need to manually catch and forward errors in each route handler.





*****Add Express Error*****
In JavaScript, particularly in the context of error handling, throw and new ExpressError have specific meanings and uses.

throw
The throw statement is used to raise an exception. When an exception is thrown, the normal flow of the code stops and control is transferred to the nearest catch block, or to the global error handler if no catch block is found.

Usage:

javascript
Copy code
throw new Error("Something went wrong");
In the context of your application:

javascript
Copy code
throw new ExpressError(400, "Send Valid data for listing");
This means that when the code encounters this line, it will stop executing the current flow and will look for an error handler to catch this specific error.

new ExpressError
new ExpressError is used to create an instance of the ExpressError class. This class is a custom error class that you've defined to handle specific errors in your application. It typically extends the built-in Error class and adds additional properties like statusCode.

Here’s an example of how the ExpressError class might be defined:

ExpressError Class:

javascript
Copy code
class ExpressError extends Error {
  constructor(statusCode, message) {
    super();
    this.statusCode = statusCode;
    this.message = message;
  }
}

module.exports = ExpressError;
In this class:

statusCode represents the HTTP status code (e.g., 400 for Bad Request, 404 for Not Found).
message is a description of the error.
When you use new ExpressError(400, "Send Valid data for listing"), you're creating a new instance of ExpressError with a status code of 400 and a message "Send Valid data for listing".

Example of Using throw with ExpressError
Here’s how you might use throw with ExpressError in a route handler:

javascript
Copy code
const ExpressError = require('./utils/ExpressError.js');

app.post("/listings", wrapAsync(async (req, res, next) => {
  if (!req.body.listing || !isValidListing(req.body.listing)) {
    throw new ExpressError(400, "Send Valid data for listing");
  }
  const newListing = new Listing(req.body.listing);
  await newListing.save();
  res.redirect("/listings");
}));

function isValidListing(listing) {
  // Validation logic for listing
  return listing.title && listing.price && listing.location; 
}
In this example, if the listing data in the request body is invalid, throw new ExpressError(400, "Send Valid data for listing") raises an exception. This exception is then caught by the error handling middleware:

javascript
Copy code
app.use((err, req, res, next) => {
  const { statusCode = 500, message = 'Something went wrong' } = err;
  res.status(statusCode).send(message);
});
This middleware sends a response with the appropriate status code and error message.

Summary
throw: Raises an exception, stopping the current flow and transferring control to an error handler.
new ExpressError: Creates a new instance of the ExpressError class, which includes an HTTP status code and a custom error message. This is used to generate specific and informative errors in your application.




*****Error.ejs****
make error.ejs in views file and we can show the error in better fashion by rendering inside app.use for error handling.




*****Validation For Schema****

 Schema => Validate => JOI(tool)

JOI:- The most powerful schema description language and data validator for JavaScript.
||
\/
Server Side Schema



*****Validation for Schema(Middleware)*****

